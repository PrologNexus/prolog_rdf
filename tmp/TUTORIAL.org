#+TITLE: plRdf Tutorial
#+AUTHOR: Wouter Beek

Note: This tutorial is currently outdated.

* Create resources and assert relations between them

Start by defining the RDF prefix that we will use throughout this
tutorial.  RDF prefixes are registeredw with ~rdf_register_prefix/2~:

#+BEGIN_SRC prolog
?- [library(semweb/rdf_ext)].
?- rdf_register_prefix(ex, 'https://example.org/').
#+END_SRC

Create fresh IRIs that name two resources:

#+BEGIN_SRC prolog
?- rdf_create_iri(ex, [animal,hog], Hog1).
?- rdf_create_iri(ex, [animal,hog], Hog2).
#+END_SRC

Assert that the new resources are hogs:

#+BEGIN_SRC prolog
?- rdf_assert($Hog1, rdf:type, ex:'Hog').
?- rdf_assert($Hog2, rdf:type, ex:'Hog').
#+END_SRC

Assert that the two hogs know each other:

#+BEGIN_SRC prolog
?- rdf_assert($Hog1, foaf:knows, $Hog2).
#+END_SRC

Notice that we did not have to declare RDF prefix ~foaf~ with
~rdf_register_prefix/2~.  Common RDF prefixes are already declarated
automatically by library ~semweb/rdf_ext~.

Let's look at the contents of our RDF graph.  For this we use the
pretty-print library:

#+BEGIN_SRC prolog
?- [library(semweb/rdf_print)].
?- rdf_print_graph(user).
〈ex:animal/hog/5b6151..., ∊, ex:Hog〉
〈ex:animal/hog/5b6155..., ∊, ex:Hog〉
〈ex:animal/hog/5b6151..., foaf:knows, ex:animal/hog/5b6155...〉
#+END_SRC

The triple dots indicate that IRI local names were elipsed to ensure
that every triple fits within an 80 character wide terminal.  The
appearance can be tweaked through options:

#+BEGIN_SRC prolog
?- rdf_print_graph(user, [ellip_ln(inf),logic_sym(false),style(turtle)]).
ex:animal/hog/5b61515c486b11e58bcb002268684c92 rdf:type ex:Hog .
ex:animal/hog/5b6155da486b11e5a357002268684c92 rdf:type ex:Hog .
ex:animal/hog/5b61515c486b11e58bcb002268684c92 foaf:knows ex:animal/hog/5b6155da486b11e5a357002268684c92 .
#+END_SRC

Option `ellip_ln(inf)` (elipsis localname) disables the use of
ellipses for IRI local names.  Option `logic_sym(false)` (logical
symbols) disables the replacement of some often occurring properties
with related logical symbolism.  Option `style(turtle)` displays
triples using a Turtle-like syntax i.o. the default tuple syntax.



Data-typed assertions
---------------------

Continuing our example of the two hogs, we can now assert the first
hog's age:

#+BEGIN_SRC prolog
?- rdf_assert_literal($Hog1, ex:age, xsd:nonNegativeInteger, 2).
?- rdf_assert_now($Hog1, ex:registrationDate).
#+END_SRC

Let's look at the contents of our graph:

#+BEGIN_SRC prolog
?- rdf_print_graph(user).
〈ex:animal/hog/5b6151..., ∊, ex:Hog〉
〈ex:animal/hog/5b6155..., ∊, ex:Hog〉
〈ex:animal/hog/5b6151..., foaf:knows, ex:animal/hog/5b6155...〉
〈ex:animal/hog/5b6151..., ex:age, "2"^^xsd:nonNegativeInteger〉
〈ex:animal/hog/5b6151..., ex:registrationDate, "2015-08-22T01:16:03Z"^^xsd:dateTime〉
#+END_SRC

If you do not want to choose an RDF datatype (like
`xsd:nonNegativeInteger` above) then you can do the following to let
the library choose an appropriate type for you:

#+BEGIN_SRC prolog
?- rdf_assert_literal_pl($Hog2, ex:age, 2.3).
?- rdf_assert_literal_pl($Hog2, ex:age, 23 rdiv 10).
?- rdf_assert_literal_pl($Hog2, rdfs:comment, "This is a fine hog.").
#+END_SRC

Our graph now has the following contents:

#+BEGIN_SRC prolog
?- rdf_print_graph(user).
〈ex:animal/hog/4d5018..., ∊, ex:Hog〉
〈ex:animal/hog/4d5020..., ∊, ex:Hog〉
〈ex:animal/hog/4d5018..., foaf:knows, ex:animal/hog/4d5020...〉
〈ex:animal/hog/4d5018..., ex:age, "2"^^xsd:nonNegativeInteger〉
〈ex:animal/hog/4d5018..., ex:registrationDate, "2015-08-22T02:27:15Z"^^xsd:dateTime〉
〈ex:animal/hog/4d5020..., ex:age, "2.3"^^xsd:float〉
〈ex:animal/hog/4d5020..., ex:age, "2.3"^^xsd:decimal〉
〈ex:animal/hog/4d5020..., rdfs:comment, "This is a fine hog."^^xsd:string〉
#+END_SRC

Notice that the RDF datatypes actually matter: `"2.3"^^xsd:float` and
`"2.3"^^xsd:decimal` denote different RDF resources even though their
lexical expressions are the same.  This library comes with support for
reading back literals as Prolog values:

#+BEGIN_SRC prolog
?- [library(rdf/rdf_read)].
?- rdf_literal($Hog2, ex:age, D, V).
D = http://www.w3.org/2001/XMLSchema#float,
V = 2.3 ;
D = http://www.w3.org/2001/XMLSchema#decimal,
V = 23 rdiv 10
#+END_SRC



RDF lists with members of mixed type
------------------------------------

RDF lists come in handy when we want to store a number of resources in
a given order.  However, the built-in predicates
`rdfs_assert_list/[2,3]` and `rdfs_list_to_prolog_list/2` in
`library(semweb/rdfs)` do not support recursive lists nor do they
allow easy assertion of typed list elements.

In the following we assert an RDF list consisting of the following
elements (in the order indicated):

  1. The integer `1`.
  
  2. The list consisting of the list containing atom `a` and the
     floating point number `1.0`.
  
  3. The atom `b` accompanied by the language tag denoting the English
     language as spoken in the United States.

The last argument denotes the named graph (`list_test`) in which the
RDF list is asserted.  All RDF assertion predicates in
`library(rdf/rdf_list)` come with variants with and without a graph
argument.

#+BEGIN_SRC prolog
?- [library(rdf/rdf_list)].
?- rdf_assert_list([1,[[a],1.0],[en,'US']-b], _X, list_test).
#+END_SRC

The list has been asserted using the RDF linked lists notation.  RDF
and XSD datatypes are used for the non-list elements and nesting is
used for the list elements:

#+BEGIN_SRC prolog
?- rdf_print_graph(list_test, [abbr_list(false)]).
〈_:2, ∊, rdf:List〉
〈_:2, rdf:first, "1"^^xsd:integer〉
〈_:3, ∊, rdf:List〉
〈_:4, ∊, rdf:List〉
〈_:5, ∊, rdf:List〉
〈_:5, rdf:first, "a"^^xsd:string〉
〈_:5, rdf:rest, rdf:nil〉
〈_:4, rdf:first, _:5〉
〈_:6, ∊, rdf:List〉
〈_:6, rdf:first, "1.0"^^xsd:float〉
〈_:6, rdf:rest, rdf:nil〉
〈_:4, rdf:rest, _:6〉
〈_:3, rdf:first, _:4〉
〈_:7, ∊, rdf:List〉
〈_:7, rdf:first, "b"@en-US〉
〈_:7, rdf:rest, rdf:nil〉
〈_:3, rdf:rest, _:7〉
〈_:2, rdf:rest, _:3〉
#+END_SRC

Since the RDF linked list notation is rather verbose library **plRdf**
allows RDF lists to be read back as Prolog lists, preserving both
nesting and taking the RDF datatypes into account:

#+BEGIN_SRC prolog
?- rdf_list($_X, Y).
Y = [1, [[a], 1.0], 'en-US'-b].
#+END_SRC


Triple store profiles
---------------------

**plRdf** comes with different profiles for storing triples.


### Plain RDF assertion

Load the 'plain' RDF profile in the following way:

#+BEGIN_SRC prolog
?- [library(profile/profile_rdf)].
#+END_SRC

This profile is similar to `library(semweb/rdf_db)`, allowing plain
triples to be asserted/retrieved/retracted.  The only difference is
that `rdf_assert/4` does not given an error in mode `(+,+,+,-)` but
calls `rdf_assert/3`.


### Generalized RDF assertion

Load the generalized RDF profile in the following way:

#+END_SRCprofile
?- [library(profile/profile_gen)].
#+END_SRC

This profile extends the plain profile by allowing literals to appear
in the subject position.  This allows all RDF(S) and OWL entailment to
be expressed in terms of RDF (something which is not possible in the
plain profile).


### OWL assertion

Load the OWL profile in the following way:

#+END_SRCprofile
?- [library(profile/profile_owl)].
#+END_SRC

This profile extends the generalized RDF profile by storing relations
between identity sets i.o. individual resources.  This significantly
speeds up calculating the identity closure (`owl:sameAs`) and avoids
OWL entailment to store the identity closure in an exponential way.
