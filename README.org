#+TITLE: prolog_rdf: Backend-agnostic Prolog-based RDF library
#+AUTHOR: Wouter Beek
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+STARTUP: inlineimages
#+STARTUP: latexpreview

This library provides advanced RDF support libraries with a focus on
supporting scalable Linked Data solutions.  The ~prolog_rdf~ library
is backend-agnostic, providing a uniform API over multiple low-level
storage implementations.  For example, ~prolog_rdf~ can be used in
combination with the following backends:

  - [[https://github.com/wouterbeek/prolog_hdt][prolog_hdt]]: A disk-based backend using limited memory resource.
  - [[http://github.com/wouterbeek/prolog_rdf_db][prolog_rdf_db]]: A high-performance, memory-intensive backend.

Please report any issues that you find when using this library.

* Installation

  1. Install [[http://www.swi-prolog.org][SWI-Prolog]].
  2. Install [[https://github.com/wouterbeek.com/Prolog-Library-Collection][Prolog-Library-Collection]].
  3. Clone this library: ~git clone https://github.com/wouterbeek/prolog_rdf~
  4. Add the following line to your ~.swiplrc~ file:

#+BEGIN_SRC
user:file_search_path(library, '/your/path/to/Pro-RDF/prolog').
#+END_SRC

Optional installtion steps:

  1. In order to use module ~[[semweb/rdf_dot]]~, library [[https://github.com/wouterbeek/graph_export][graph_export]]
     must be installed.
  2. In order to use module ~[[semweb/rdf_geo]]~, library [[https://github.com/wouterbeek/Pro-GIS][Pro-GIS]] must be
     installed.

* Usage

After [[Installation]], libraries can be loaded in the following way:

#+BEGIN_SRC prolog
:- [library(semweb/rdf_term)].
#+END_SRC

* RDF-specific Prolog types

This library uses the following extended Prolog types in the
documentation headers of predicates:

  | *Type*        | *Definition*                                                                         |   |
  |---------------+--------------------------------------------------------------------------------------+---|
  | ~rdf_bnode~   | An atom that starts with ~_:~.                                                       |   |
  | ~rdf_graph~   | Either a term of type ~iri~ or the atom ~default~.                                   |   |
  | ~rdf_iri~     | An atom that can be decomposed with ~uri_components/2~ from ~library(uri)~.          |   |
  | ~rdf_literal~ | A compound term of the form ~literal(type(iri,atom))~ or ~literal(lang(atom,atom))~. |   |
  | ~rdf_name~    | An RDF name (IRI or literal).                                                        |   |
  | ~rdf_quad~    | A compound term of the form ~rdf(rdf_nonliteral,iri,rdf_term,rdf_graph)~.            |   |
  | ~rdf_term~    | An RDF term (blank node, IRI, or literal).                                           |   |
  | ~rdf_triple~  | A compound term of the form ~rdf(rdf_nonliteral,iri,rdf_term)~.                      |   |
  | ~rdf_tuple~   | A term of type ~rdf_quad~ or ~rdf_triple~.                                           |   |

* Modules

This section enumerates the various modules that are included in
Pro-RDF.

** ~/html/rdf_html~

This module provides DCG rules that generate simple human-readable
HTML snippets that represent RDF terms and tuples.

** ~/http/rdf_http~

This module supports the use of RDF terms in HTTP APIs, by
encoding/decoding URI query components that contain RDF terms.

** ~/semweb/rdf_api~

Provides higher-level RDF functionality based on low-level backend
operations.  The backend operations themselves are not part of this
Pro-RDF library, and should be added independently.  See [[https://github.com/wouterbeek/Pro-HDT][Pro-HDT]] and
[[https://github.com/wouterbeek/Pro-RDF-DB][Pro-RDF-DB]] for two such backends.

** ~/semweb/rdf_clean~

This module contains data cleaning predicates that were previously
part of [[http://lodlaundromat.org][LOD Laundromat]].  They can be used to clean RDF tuples that are
streamed from an RDF source.  See module ~[[semweb/rdf_deref]]~ for
creating streams over RDF sources.

*** Blank node cleaning

The parsers in the Semantic Web standard library emit blank node
labels that contain characters that are not allowed in
standards-compliant output formats (e.g., forward slashes).  This is
unfortunate, since writing the data into standard-compliant formats
requires maintaining a state that ensures that Prolog internal blank
node labels are consistently emitted by the same standard-compliant
external blank node label.  See [[https://github.com/SWI-Prolog/packages-semweb/issues/68][this Github issue]] for context.

Besides the above considerations, blank nodes form a scalability issue
in general.  Since blank node labels are only guaranteed to be unique
within the context of an RDF document, combining data from multiple
documents requires a check of all blank node labels in the to be
combined documents.  Furthermore, all blank node labels that appear in
more than one RDF document must be consistently renamed prior to
combining the data.

Since Pro-RDF focusses on scalability, it cannot rely on maintaining
an internal state that consistently maps internal Prolog blank node
labels to external standards-compliant blank node labels.  For the
same reasons, it also cannot rely on full document inspection and
blank node relabeling approaches.  For these reasons, the data
cleaning prediates in ~semweb/rdf_clean~ replace blank nodes with
well-known IRIs, in line with the RDF 1.1 standard.  This means that
every data cleaning predicate must bind a valid well-known IRI to the
~BNodePrefix~ argument.  It also means that Prolog internal blank node
labels are hashed using the MD5 algorithm to provide the local names
for the generated well-known IRIs.  The latter ensures consistent
relabeling without maintaining an internal state.

*** Graph cleaning

The parsers from the Semantic Web standard library denote the default
graph with atom ~user~.  This is translated to atom ~default~.  For
named graphs, this library checks whether they are well-formed IRIs.

*** IRI cleaning

IRI cleaning is the most difficult part of syntactic RDF data
cleaning.  To date, the IRI grammar ([[https://tools.ietf.org/html/rfc3987][RFC 3987]]) has not yet been
implemented.  Since this grammar was published over a decade ago, we
must anticipate a future in which the main syntactic component of the
Semantic Web cannot be validated.

While there are implementations of the URI grammar ([[https://tools.ietf.org/html/rfc3986][RFC 3986]]), the one
provided by the Prolog standard library (~library(uri)~) is incorrect.

Because of the above two reasons we currently only check the following:
  - Whether an IRI can be decomposed into scheme, authority, path,
    query, and fragment components using the Prolog standard library
    grammar (~uri_components/2~).
  - Whether the scheme, authority, and path components are non-empty.
  - Whether the scheme components conforms to the IRI grammar.

*** Literal cleaning

For language-tagged strings, cleaning involves downcasing the language
tag.  While there are implementations of the language tag grammar ([[https://tools.ietf.org/html/rfc5646][RFC
5646]]), we are not yet using these.

Simple literals, i.e., literals with neither language tag not datatype
IRI, are translated to typed literals with datatype IRI ~xsd:string~.

For typed literals, cleaning involves:
  - Cleaning the datatype IRI (see [[IRI cleaning]]).
  - Making sure the datatype IRI is not ~rdf:langString~.
  - Cleaning the lexical form according to the datatype IRI.  Lexical
    form cleaning is the most involved step, since there are many
    different datatype IRIs.  Since it is impractical to implement
    lexical form cleaning for all datatype IRIs, we focus on those
    that are most widely used.  For this we use ~rdf_literal_value/3~,
    which is part of library ~semweb/rdf_term~.

*** Predicates

This library provides the following predicates:

- ~rdf_clean_quad(+Site:uri, +Dirty:rdf_quad, -Clean:rdf_quad)~

  Cleans quadruple compound terms.

- ~rdf_clean_triple(+Site:uri, +Dirty:rdf_triple, -Clean:rdf_triple)~

  Cleans triple compound terms.

- ~rdf_clean_tuple(+Site:uri, +Dirty:rdf_tuple, -Clean:rdf_tuple)~

  Cleans quadruple and/or triple compound terms.

** ~/semweb/rdf_deref~

This module implements RDF dereferencing, i.e., the act of obtaining
interpreted RDF statements based on a given RDF document, stream, or
HTTP(S) URI.

*** Predicates

This library provides the following predicates:

  - ~rdf_deref_file/[2,3]~ calls RDF dereferencing on local RDF
    documents.  Uses heuristics in order to determine the RDF
    serialization of the file.

  - ~rdf_deref_stream/[3,4]~ performs RDF dereferencing on an input
    stream containing one of the standardized RDF serialization
    formats.

  - ~rdf_dered_uri/[2,3]~ performs RDF dereferencing on a URI,
    typically an HTTP(S) URI.  Uses heuristics in order to determine
    the RDF serialization of the reply body.

** ~/semweb/rdf_dot~

This library provides primitives for generating GraphViz DOT exports
of RDF terms and tuples.

This module requires library [[https://github.com/wouterbeek/graph_export][graph_export]] to be installed.

** ~/semweb/rdf_export~

This module writes RDF data in a simple and standards-compliant
serialization format.  It contains the following predicates:

  - ~rdf_write_iri/2~
  - ~rdf_write_literal/2~
  - ~rdf_write_name/2~
  - ~rdf_write_quad/[2,3,5]~
  - ~rdf_write_triple/[2,4]~
  - ~rdf_write_tuple/2~

** ~/semweb/rdf_geo~

This module extends hooks into module ~/semweb/rdf_term~ that allow
GeoSPARQL-compliant geo-spatial objects to be read and written.

This module currently supports the following serialization formats for
geometries:

  - Well Known Text (WKT)

This module requires library [[https://github.com/wouterbeek/Pro-GIS][Pro-GIS]] to be installed.

** ~/semweb/rdf_guess~

This module peeks at the beginning of a file, stream, or string in
order to heuristically guesstimate the RDF serialization formats (if
any) containing in that input:

  - ~rdf_guess_file/3~
  - ~rdf_guess_stream/3~
  - ~rdf_guess_string/2~

** ~/semweb/rdf_media_type~

This module provides support for the standardized RDF serialization
format Media Types:

  - ~rdf_file_name_media_type/2~ guesses the RDF serialization format
    based on the file name extension alone.

  - ~rdf_media_type/1~ enumerates all standardized RDF Media Types.

  - ~'rdf_media_type_>'/2 succeeds if the former argument is an RDF
    Media Type that syntactically encompasses the latter argument
    (e.g., TriG > Turtle > N-Triples, N-Quads > N-Triples).

  - ~rdf_media_type_extension~ gives a standard file name extension
    for RDF serializations that are not RDFa (which is part of HTML or
    XHTML content).

  - ~rdfa_media_type/1~ succeeds for RDFa Media Types.

** ~/semweb/rdf_prefix~

This module provides extended support for working with RDF prefix
declarations:

*** ~rdf_prefix/[1,2]~

Enumerates the currently declared RDF prefix declarations.

*** ~rdf_prefix_any/2~

*** ~rdf_prefix_append/[2,3]~

*** ~rdf_prefix_iri/[2,3]~

Succeeds for (alias,local-name) pairs and full IRIs.

*** ~rdf_prefix_maplist/[2,3]~

*** ~rdf_prefix_member/2~

*** ~rdf_prefix_memberchk/2~

Provide the corresponding popular Prolog predicates, but apply RDF
prefix notation expansion on their arguments.

RDF prefix expansion must be specifically declared for arguments in
predicates.  In the SWI-Prolog standard libraries, such declarations
have only been added for predicates in the Semantic Web libraries, but
not for predicates in other standard libraries.  For example, the
following will not check whether ~P~ is bound to either of the four
RDFS properties, because the prefix notation is not expanded:

#+BEGIN_SRC prolog
memberchk(P, [rdfs:domain,rdfs:range,rdfs:subClassOf,rdfs:subPropertyOf]),
#+END_SRC

Wiht the Semantic Web standard library, the above call must be spelled
out using ~rdf_equal/2~ in the following way:

#+BEGIN_SRC prolog
(   rdf_equal(P, rdfs:domain)
->  true
;   rdf_equal(P, rdfs:range)
->  true
;   rdf_equal(P, rdfs:subClassOf)
->  true
;   rdf_equal(P, rdfs:subPropertyOf)
->  true
),
#+END_SRC

When ~library(semweb/rdf_prefix)~ is loade, the above can be written
as follows:

#+BEGIN_SRC prolog
rdf_prefix_memberchk(P, [rdfs:domain,rdfs:range,rdfs:subClassOf,rdfs:subPropertyOf]),
#+END_SRC

*** ~rdf_prefix_selectchk/3~

*** ~rdf_prefix_term/2~

*** ~rdf_register_prefix/[1-3]~

*** ~rdf_register_prefixes/0~

** ~semweb/rdf_print~

This module provides DCG rules for printing RDF terms and tuples.

** ~semweb/rdf_term~

This module provides advanced support for composing, decomposing,
parsing, and generating RDF terms.

** ~semweb/rdf_triple~

** ~semweb/schema_viz~

** ~semweb/sparql_functions~

** ~xsd/xsd~

Support for XML Schema 1.1 Part 2: Datatypes.

  - ~xsd_date_time/3~ for translating between XSD date/time
    representations and date/time representations as supported by
    [[https://github.com/wouterbeek/Prolog-Library-Collection][Prolog-Library-Collection]].

  - ~xsd_date_time_type/1~ for checking/enumerating the XSD date/time
    datatype IRIs.

  - ~xsd_encode_string//0~ a DCG rule for encoding strings of
    characters according to the restrictions of the XSD string
    datatype.

  - ~xsd_numeric_type/1~ enumerates XSD numeric datatype IRIs.

  - ~xsd_strict_subtype/2~ and ~xsd:subtype/2~ allow the hierarchy of
    XSD datatype IRIs to be queried.

** ~xsd/xsd_grammar~

DCG grammar rules for decimal and duration datatypes that are not yet
supported by SWI-Prolog.
